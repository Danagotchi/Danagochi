<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Danagotchi</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
  touch-callout: none;
}
body {
  overflow: hidden;
  background: #e8e6d9;
  height: 100vh;
}
#room {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
#pet {
  position: absolute;
  width: 120px;
  height: 120px;
  image-rendering: pixelated;
  cursor: grab;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transition: none;
}
#pet:active {
  cursor: grabbing;
}
</style>
</head>
<body>
<div id="room">
  <img id="pet" src="normal1.png">
</div>

<script>
const pet = document.getElementById('pet');
// 动作配置
const actions = {
  normal: ['normal1.png','normal2.png'],
  click: ['click1.png','click2.png'],
  walk: ['walk1.png','walk2.png'],
  sit: ['sit1.png','sit2.png'],
  lie: ['lie1.png','lie2.png'],
  sleep: ['sleep1.png','sleep2.png'],
  drag: ['drag1.png','drag2.png']
};

// 核心状态变量
let currentAction = 'normal';
let frame = 0;
let frameInterval;          // 动画帧切换定时器
let walkInterval;           // 走动动画定时器
let idleTimer = null;       // 待机状态下的随机动作定时器
let isWalking = false;      // 是否正在走动
let isDragging = false;     // 是否正在拖动
let walkDirection = { x: 0, y: 0, speed: 0 };
const DRAG_THRESHOLD = 5;   // 拖动判定阈值
const PET_SIZE = 120;       // 宠物尺寸
// 时间区间
const IDLE_MIN = 1000, IDLE_MAX = 4000;
const WALK_MIN = 3000, WALK_MAX = 5000;
const IDLE_ACT_MIN = 1000, IDLE_ACT_MAX = 4000;

// 获取屏幕边界
function getBounds() {
  return { 
    minX: 0, 
    minY: 0, 
    maxX: document.documentElement.clientWidth - PET_SIZE, 
    maxY: document.documentElement.clientHeight - PET_SIZE 
  };
}

// 动画帧循环
function startAnim() {
  clearInterval(frameInterval);
  frameInterval = setInterval(() => {
    frame = 1 - frame;
    pet.src = actions[currentAction][frame];
  }, 500);
}

// 切换动作
function setAction(name, force = false) {
  // 拖动/点击优先级高于其他动作
  if (!force && (isDragging || currentAction === 'click')) return;
  if (currentAction === name) return;
  
  currentAction = name;
  frame = 0;
  pet.src = actions[name][0];
  
  // 切换到待机状态，立即启动定时器
  if (name === 'normal') {
    startIdleTimer();
  }
}

// 随机数生成
const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

// 初始化走动方向
function initWalkDirection() {
  walkDirection.x = rand(-10, 10) / 10;
  walkDirection.y = rand(-10, 10) / 10;
  const mag = Math.hypot(walkDirection.x, walkDirection.y) || 1;
  walkDirection.x /= mag;
  walkDirection.y /= mag;
  walkDirection.speed = rand(10, 15) / 10; // 走动速度
  
  // 确保初始位置在边界内
  const { minX, minY, maxX, maxY } = getBounds();
  pet.style.left = `${Math.max(minX, Math.min(maxX, pet.offsetLeft))}px`;
  pet.style.top = `${Math.max(minY, Math.min(maxY, pet.offsetTop))}px`;
}

// 边界检测+反弹
function checkBounds() {
  const { minX, minY, maxX, maxY } = getBounds();
  let x = parseFloat(pet.style.left || pet.offsetLeft);
  let y = parseFloat(pet.style.top || pet.offsetTop);
  let bounced = false;

  if (x <= minX) { x = minX; walkDirection.x = Math.abs(walkDirection.x); bounced = true; }
  else if (x >= maxX) { x = maxX; walkDirection.x = -Math.abs(walkDirection.x); bounced = true; }
  
  if (y <= minY) { y = minY; walkDirection.y = Math.abs(walkDirection.y); bounced = true; }
  else if (y >= maxY) { y = maxY; walkDirection.y = -Math.abs(walkDirection.y); bounced = true; }

  if (bounced) {
    pet.style.left = `${x}px`;
    pet.style.top = `${y}px`;
  }
}

// 走动逻辑
function doWalk() {
  if (isDragging || currentAction === 'click') {
    stopWalk();
    return;
  }

  if (!isWalking) {
    setAction('walk', true);
    isWalking = true;
    initWalkDirection();
  }

  // 更新位置
  let x = parseFloat(pet.style.left || pet.offsetLeft) + walkDirection.x * walkDirection.speed;
  let y = parseFloat(pet.style.top || pet.offsetTop) + walkDirection.y * walkDirection.speed;
  pet.style.left = `${x}px`;
  pet.style.top = `${y}px`;
  
  checkBounds();
}

// 停止走动
function stopWalk() {
  clearInterval(walkInterval);
  walkInterval = null;
  isWalking = false;
  if (!isDragging && currentAction !== 'click') {
    setAction('normal');
  }
}

// 触发随机走动
function triggerWalk() {
  if (isDragging || currentAction === 'click' || isWalking) return;
  
  stopWalk();
  walkInterval = setInterval(doWalk, 16);
  
  // 3-5秒后停止走动，恢复待机
  setTimeout(() => {
    if (!isDragging && currentAction !== 'click') {
      stopWalk();
    }
  }, rand(WALK_MIN, WALK_MAX));
}

// 触发随机原地动作
function triggerIdleAction() {
  if (isDragging || currentAction === 'click' || isWalking) return;
  
  const idleActions = ['sit', 'lie', 'sleep'];
  const target = idleActions[Math.floor(Math.random() * idleActions.length)];
  setAction(target, true);
  
  // 1-4秒后恢复待机
  setTimeout(() => {
    if (!isDragging && !isWalking && currentAction !== 'click') {
      setAction('normal');
    }
  }, rand(IDLE_ACT_MIN, IDLE_ACT_MAX));
}

// 启动待机定时器
function startIdleTimer() {
  // 清除原有定时器
  clearTimeout(idleTimer);
  // 仅在待机状态下启动定时器
  if (currentAction === 'normal' && !isDragging && !isWalking) {
    idleTimer = setTimeout(() => {
      // 触发随机动作
      Math.random() > 0.5 ? triggerWalk() : triggerIdleAction();
    }, rand(IDLE_MIN, IDLE_MAX));
  }
}

// 停止待机定时器
function stopIdleTimer() {
  clearTimeout(idleTimer);
  idleTimer = null;
}

// 处理拖动逻辑
function handleDrag(startX, startY) {
  isDragging = true;
  stopWalk();
  stopIdleTimer();
  setAction('drag', true);
  
  const petX = parseFloat(pet.style.left || pet.offsetLeft);
  const petY = parseFloat(pet.style.top || pet.offsetTop);
  const { minX, minY, maxX, maxY } = getBounds();

  // 移动处理
  const handleMove = (x, y) => {
    const nx = petX + x - startX;
    const ny = petY + y - startY;
    pet.style.left = `${Math.max(minX, Math.min(maxX, nx))}px`;
    pet.style.top = `${Math.max(minY, Math.min(maxY, ny))}px`;
  };

  // 结束拖动
  const handleEnd = () => {
    isDragging = false;
    setAction('normal', true);
    // 移除事件监听
    window.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('mouseup', onMouseUp);
    window.removeEventListener('touchmove', onTouchMove);
    window.removeEventListener('touchend', onTouchEnd);
  };

  // 事件处理函数
  const onMouseMove = (e) => handleMove(e.clientX, e.clientY);
  const onMouseUp = () => handleEnd();
  const onTouchMove = (e) => handleMove(e.touches[0].clientX, e.touches[0].clientY);
  const onTouchEnd = () => handleEnd();

  // 绑定事件
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
  window.addEventListener('touchmove', onTouchMove);
  window.addEventListener('touchend', onTouchEnd);
}

// 点击事件处理
function handleClick() {
  if (isDragging) return;
  
  stopWalk();
  stopIdleTimer();
  setAction('click', true);
  
  // 2秒后恢复待机
  setTimeout(() => {
    if (!isDragging) {
      setAction('normal', true);
    }
  }, 2000);
}

// 拖动处理
function handleDown(startX, startY, onUp) {
  let dragTimer = setTimeout(() => {
    handleDrag(startX, startY);
  }, 100);

  // 松开判定
  const checkUp = (endX, endY) => {
    clearTimeout(dragTimer);
    // 计算位移，小于阈值则判定为点击
    const dx = endX - startX;
    const dy = endY - startY;
    if (Math.hypot(dx, dy) < DRAG_THRESHOLD) {
      handleClick();
    }
    onUp();
  };

  return checkUp;
}

// PC端拖动/点击
pet.addEventListener('mousedown', (e) => {
  e.preventDefault();
  const startX = e.clientX;
  const startY = e.clientY;
  
  const checkUp = handleDown(startX, startY, () => {
    window.removeEventListener('mouseup', onMouseUp);
  });

  const onMouseUp = (e) => checkUp(e.clientX, e.clientY);
  window.addEventListener('mouseup', onMouseUp);
});

// 移动端拖动/点击
pet.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const startX = touch.clientX;
  const startY = touch.clientY;
  
  const checkUp = handleDown(startX, startY, () => {
    window.removeEventListener('touchend', onTouchEnd);
  });

  const onTouchEnd = (e) => {
    const touch = e.changedTouches[0];
    checkUp(touch.clientX, touch.clientY);
  };
  window.addEventListener('touchend', onTouchEnd);
});

// 窗口大小变化时调整位置
window.addEventListener('resize', () => {
  const { minX, minY, maxX, maxY } = getBounds();
  pet.style.left = `${Math.max(minX, Math.min(maxX, pet.offsetLeft))}px`;
  pet.style.top = `${Math.max(minY, Math.min(maxY, pet.offsetTop))}px`;
  
  if (isWalking) initWalkDirection();
});

// 初始化
startAnim();
setAction('normal');
</script>
</body>
</html>
