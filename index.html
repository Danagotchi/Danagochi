<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Danagotchi</title>
<style>
*{
  margin:0;
  padding:0;
  box-sizing:border-box;
  -webkit-user-select:none;
  user-select:none;
  -webkit-touch-callout:none;
}
body{
  overflow:hidden;
  background:#000;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
}
#room{
  position:relative;
  width:100vw;
  height:100vh;
  /* 改为纯色背景 */
  background-color: #e8e6d9;
  overflow:hidden;
}
#pet{
  position:absolute;
  width:120px;
  height:120px;
  image-rendering:pixelated;
  cursor:grab;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
}
#pet:active{
  cursor:grabbing;
}
</style>
</head>
<body>
<div id="room">
  <img id="pet" src="normal1.png">
</div>

<script>
const pet = document.getElementById('pet');
const room = document.getElementById('room');

// 动作配置
const actions = {
  normal: ['normal1.png','normal2.png'],
  click: ['click1.png','click2.png'],
  walk: ['walk1.png','walk2.png'],
  sit: ['sit1.png','sit2.png'],
  lie: ['lie1.png','lie2.png'],
  sleep: ['sleep1.png','sleep2.png'],
  drag: ['drag1.png','drag2.png']
};

let currentAction = 'normal';
let frame = 0;
let frameInterval;
let walkInterval; // 替换原有moveInterval，用于走动动画
let idleActionInterval;
let isWalking = false; // 标记是否正在走动
let walkDirection = { x: 0, y: 0, speed: 0 }; // 走动方向和速度

let isDragging = false;
let startX, startY, petX, petY;

// 房间边界
function getBounds() {
  // 可视区域宽高
  const viewW = document.documentElement.clientWidth;
  const viewH = document.documentElement.clientHeight;
  // 宠物宽高
  const petW = 120;
  const petH = 120;
  // 最大可移动范围 = 屏幕 - 宠物自身大小
  const maxX = viewW - petW;
  const maxY = viewH - petH;
  return { minX: 0, minY: 0, maxX, maxY };
}

// 动画帧循环 2帧/秒
function startAnim(){
  clearInterval(frameInterval);
  frameInterval = setInterval(()=>{
    frame = 1 - frame;
    pet.src = actions[currentAction][frame];
  },500);
}

// 切换动作（增加是否强制参数，确保优先级）
function setAction(name, force = false){
  // 非强制切换时，高优先级动作正在进行则不切换
  if(!force && (isDragging || currentAction === 'click')) return;
  if(currentAction === name) return;
  currentAction = name;
  frame = 0;
  pet.src = actions[name][0];
}

// 随机数
function rand(min,max){
  return Math.random()*(max-min)+min;
}

// 随机待机动作
const idleActions = ['sit','lie','sleep'];
function randomIdleAction(){
  if(isDragging || isWalking || currentAction === 'click') return;
  const targetAction = idleActions[Math.floor(rand(0,idleActions.length))];
  setAction(targetAction);
  setTimeout(()=>{
    if(!isDragging && !isWalking && currentAction !== 'click') {
      setAction('normal');
    }
  },rand(3000,5000));
}

// 初始化走动方向
function initWalkDirection() {
  const { minX, minY, maxX, maxY } = getBounds();
  // 随机初始方向
  walkDirection.x = rand(-1, 1);
  walkDirection.y = rand(-1, 1);
  // 确保有移动速度
  walkDirection.speed = rand(0.5, 1.2);
  // 归一化方向向量
  const mag = Math.hypot(walkDirection.x, walkDirection.y);
  walkDirection.x = walkDirection.x / mag;
  walkDirection.y = walkDirection.y / mag;
  
  // 确保宠物在边界内
  let x = pet.offsetLeft;
  let y = pet.offsetTop;
  x = Math.max(minX, Math.min(maxX, x));
  y = Math.max(minY, Math.min(maxY, y));
  pet.style.left = x + 'px';
  pet.style.top = y + 'px';
}

// 边界检测并反弹
function checkBoundsAndBounce() {
  const { minX, minY, maxX, maxY } = getBounds();
  let x = pet.offsetLeft;
  let y = pet.offsetTop;
  
  // 碰到左右边界反弹
  if (x <= minX) {
    x = minX;
    walkDirection.x = Math.abs(walkDirection.x);
  } else if (x >= maxX) {
    x = maxX;
    walkDirection.x = -Math.abs(walkDirection.x);
  }
  
  // 碰到上下边界反弹
  if (y <= minY) {
    y = minY;
    walkDirection.y = Math.abs(walkDirection.y);
  } else if (y >= maxY) {
    y = maxY;
    walkDirection.y = -Math.abs(walkDirection.y);
  }
  
  // 更新位置
  pet.style.left = x + 'px';
  pet.style.top = y + 'px';
}

// 持续走动（带边界反弹）
function continuousWalk() {
  if (isDragging || currentAction === 'click') {
    stopWalking();
    return;
  }
  
  if (!isWalking) {
    setAction('walk');
    isWalking = true;
    initWalkDirection();
  }
  
  // 移动宠物
  let x = pet.offsetLeft + walkDirection.x * walkDirection.speed;
  let y = pet.offsetTop + walkDirection.y * walkDirection.speed;
  pet.style.left = x + 'px';
  pet.style.top = y + 'px';
  
  // 检测边界并反弹
  checkBoundsAndBounce();
}

// 停止走动
function stopWalking() {
  if (walkInterval) {
    clearInterval(walkInterval);
    walkInterval = null;
  }
  isWalking = false;
  if (!isDragging && currentAction !== 'click') {
    setAction('normal');
  }
}

// 随机触发走动（替代原有randomWalk）
function triggerRandomWalk() {
  if (isDragging || currentAction === 'click' || isWalking) return;
  
  // 启动持续走动
  stopWalking(); // 确保先停止之前的走动
  walkInterval = setInterval(continuousWalk, 16); // 约60fps
  
  // 随机时长后停止走动
  setTimeout(() => {
    if (!isDragging && currentAction !== 'click') {
      stopWalking();
    }
  }, rand(2000, 5000));
}

// 自动行为
function startAI(){
  clearInterval(idleActionInterval);
  // 随机触发走动
  idleActionInterval = setInterval(() => {
    if (!isDragging && currentAction !== 'click' && !isWalking) {
      triggerRandomWalk();
    }
  }, rand(2000, 5000));
  
  // 随机触发待机动作
  setInterval(randomIdleAction, rand(3000, 5000));
}

// 点击（优先级第二，强制打断）
pet.addEventListener('click',()=>{
  if(isDragging) return;
  // 停止所有当前动作
  stopWalking();
  clearInterval(idleActionInterval);
  // 强制切换到点击动作
  setAction('click', true);
  setTimeout(()=>{
    if(!isDragging) {
      setAction('normal', true);
      startAI(); // 恢复自动行为
    }
  },800);
});

// 拖动 - 电脑（优先级最高）
pet.addEventListener('mousedown',(e)=>{
  isDragging = true;
  // 强制停止所有动作
  stopWalking();
  clearInterval(idleActionInterval);
  // 强制切换到拖动动作
  setAction('drag', true);
  pet.style.transition = 'none';
  startX = e.clientX;
  startY = e.clientY;
  petX = pet.offsetLeft;
  petY = pet.offsetTop;
  e.preventDefault();
});

// 拖动 - 手机（优先级最高）
pet.addEventListener('touchstart',(e)=>{
  isDragging = true;
  // 强制停止所有动作
  stopWalking();
  clearInterval(idleActionInterval);
  // 强制切换到拖动动作
  setAction('drag', true);
  pet.style.transition = 'none';
  const t = e.touches[0];
  startX = t.clientX;
  startY = t.clientY;
  petX = pet.offsetLeft;
  petY = pet.offsetTop;
  e.preventDefault();
});

window.addEventListener('mousemove',(e)=>{
  if(!isDragging) return;
  const { minX, minY, maxX, maxY } = getBounds();
  const nx = petX + e.clientX - startX;
  const ny = petY + e.clientY - startY;
  // 限制拖动范围在边界内
  const clampedX = Math.max(minX, Math.min(maxX, nx));
  const clampedY = Math.max(minY, Math.min(maxY, ny));
  pet.style.left = clampedX + 'px';
  pet.style.top = clampedY + 'px';
});

window.addEventListener('touchmove',(e)=>{
  if(!isDragging) return;
  const { minX, minY, maxX, maxY } = getBounds();
  const t = e.touches[0];
  const nx = petX + t.clientX - startX;
  const ny = petY + t.clientY - startY;
  // 限制拖动范围在边界内
  const clampedX = Math.max(minX, Math.min(maxX, nx));
  const clampedY = Math.max(minY, Math.min(maxY, ny));
  pet.style.left = clampedX + 'px';
  pet.style.top = clampedY + 'px';
  e.preventDefault();
});

window.addEventListener('mouseup',()=>{
  if(!isDragging) return;
  isDragging = false;
  setAction('normal', true);
  startAI(); // 恢复自动行为
});

window.addEventListener('touchend',()=>{
  if(!isDragging) return;
  isDragging = false;
  setAction('normal', true);
  startAI(); // 恢复自动行为
});

// 窗口大小变化时重新计算边界
window.addEventListener('resize', () => {
  if (isWalking) {
    initWalkDirection();
  }
});

// 启动
startAnim();
setAction('normal');
startAI();
</script>
</body>
</html>
