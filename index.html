<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Danagotchi</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
  touch-callout: none;
}
body {
  overflow: hidden;
  background: #e8e6d9;
  height: 100vh;
}
#room {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
#pet {
  position: absolute;
  width: 120px;
  height: 120px;
  image-rendering: pixelated;
  cursor: grab;
  left: calc(50% - 60px);
  top: calc(50% - 60px);
  transition: none;
}
#pet:active {
  cursor: grabbing;
}
</style>
</head>
<body>
<div id="room">
  <img id="pet" src="normal1.png">
</div>

<script>
const pet = document.getElementById('pet');
// 动作配置
const actions = {
  normal: ['normal1.png','normal2.png'],
  click: ['click1.png','click2.png'],
  walk: ['walk1.png','walk2.png'],
  sit: ['sit1.png','sit2.png'],
  lie: ['lie1.png','lie2.png'],
  sleep: ['sleep1.png','sleep2.png'],
  drag: ['drag1.png','drag2.png']
};

// 核心状态变量
let currentAction = 'normal';
let frame = 0;
let frameInterval;          
let walkInterval;           
let idleTimer = null;       
let isWalking = false;      
let isDragging = false;     
let walkDirection = { x: 0, y: 0, speed: 0 };
const DRAG_THRESHOLD = 5;   
const PET_SIZE = 120;       
// 固定时间区间
const IDLE_MIN = 1000, IDLE_MAX = 4000;
const WALK_MIN = 3000, WALK_MAX = 5000;
const IDLE_ACT_MIN = 1000, IDLE_ACT_MAX = 4000;

// 获取屏幕边界
function getBounds() {
  const clientW = document.documentElement.clientWidth;
  const clientH = document.documentElement.clientHeight;
  return { 
    minX: 0,                  // 左边缘严格0
    minY: 0,                  // 上边缘严格0
    maxX: clientW - PET_SIZE, // 右边缘：屏幕宽-宠物宽
    maxY: clientH - PET_SIZE  // 下边缘：屏幕高-宠物高
  };
}

// 动画帧循环
function startAnim() {
  clearInterval(frameInterval);
  frameInterval = setInterval(() => {
    frame = 1 - frame;
    pet.src = actions[currentAction][frame];
  }, 500);
}

// 切换动作
function setAction(name, force = false) {
  if (!force && (isDragging || currentAction === 'click')) return;
  if (currentAction === name) return;
  
  currentAction = name;
  frame = 0;
  pet.src = actions[name][0];
  
  if (name === 'normal') {
    startIdleTimer();
  }
}

// 随机数生成
const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

// 初始化走动方向
function initWalkDirection() {
  walkDirection.x = rand(-10, 10) / 10;
  walkDirection.y = rand(-10, 10) / 10;
  const mag = Math.hypot(walkDirection.x, walkDirection.y) || 1;
  walkDirection.x /= mag;
  walkDirection.y /= mag;
  walkDirection.speed = rand(10, 15) / 10;
  
  // 校准初始位置
  const { minX, minY, maxX, maxY } = getBounds();
  let x = getPetX();
  let y = getPetY();
  pet.style.left = `${Math.max(minX, Math.min(maxX, x))}px`;
  pet.style.top = `${Math.max(minY, Math.min(maxY, y))}px`;
}

// 获取当前X/Y纯数字值
function getPetX() {
  return parseFloat(pet.style.left) || 0;
}
function getPetY() {
  return parseFloat(pet.style.top) || 0;
}

// 边界检测+反弹
function checkBounds() {
  const { minX, minY, maxX, maxY } = getBounds();
  let x = getPetX();
  let y = getPetY();
  let bounced = false;

  // 左边缘：小于0则强制设为0，方向反弹
  if (x < minX) { x = minX; walkDirection.x = Math.abs(walkDirection.x); bounced = true; }
  // 右边缘：大于最大值则强制设为最大值，方向反弹
  else if (x > maxX) { x = maxX; walkDirection.x = -Math.abs(walkDirection.x); bounced = true; }
  // 上边缘：小于0则强制设为0，方向反弹
  if (y < minY) { y = minY; walkDirection.y = Math.abs(walkDirection.y); bounced = true; }
  // 下边缘：大于最大值则强制设为最大值，方向反弹
  else if (y > maxY) { y = maxY; walkDirection.y = -Math.abs(walkDirection.y); bounced = true; }

  if (bounced) {
    pet.style.left = `${x}px`;
    pet.style.top = `${y}px`;
  }
}

// 走动逻辑
function doWalk() {
  if (isDragging || currentAction === 'click') {
    stopWalk();
    return;
  }

  if (!isWalking) {
    setAction('walk', true);
    isWalking = true;
    initWalkDirection();
  }

  let x = getPetX() + walkDirection.x * walkDirection.speed;
  let y = getPetY() + walkDirection.y * walkDirection.speed;
  pet.style.left = `${x}px`;
  pet.style.top = `${y}px`;
  
  checkBounds();
}

// 停止走动
function stopWalk() {
  clearInterval(walkInterval);
  walkInterval = null;
  isWalking = false;
  if (!isDragging && currentAction !== 'click') {
    setAction('normal');
  }
}

// 触发随机走动
function triggerWalk() {
  if (isDragging || currentAction === 'click' || isWalking) return;
  
  stopWalk();
  walkInterval = setInterval(doWalk, 16);
  
  setTimeout(() => {
    if (!isDragging && currentAction !== 'click') {
      stopWalk();
    }
  }, rand(WALK_MIN, WALK_MAX));
}

// 触发随机原地动作
function triggerIdleAction() {
  if (isDragging || currentAction === 'click' || isWalking) return;
  
  const idleActions = ['sit', 'lie', 'sleep'];
  const target = idleActions[Math.floor(Math.random() * idleActions.length)];
  setAction(target, true);
  
  setTimeout(() => {
    if (!isDragging && !isWalking && currentAction !== 'click') {
      setAction('normal');
    }
  }, rand(IDLE_ACT_MIN, IDLE_ACT_MAX));
}

// 启动待机定时器
function startIdleTimer() {
  clearTimeout(idleTimer);
  if (currentAction === 'normal' && !isDragging && !isWalking) {
    idleTimer = setTimeout(() => {
      Math.random() > 0.5 ? triggerWalk() : triggerIdleAction();
    }, rand(IDLE_MIN, IDLE_MAX));
  }
}

// 停止待机定时器
function stopIdleTimer() {
  clearTimeout(idleTimer);
  idleTimer = null;
}

// 处理拖动逻辑
function handleDrag(startX, startY) {
  isDragging = true;
  stopWalk();
  stopIdleTimer();
  setAction('drag', true);
  
  const petX = getPetX();
  const petY = getPetY();
  const { minX, minY, maxX, maxY } = getBounds();

  // 实时强制限制在四边缘内
  const handleMove = (x, y) => {
    let nx = petX + x - startX;
    let ny = petY + y - startY;
    // 强制校准
    nx = Math.max(minX, Math.min(maxX, nx));
    ny = Math.max(minY, Math.min(maxY, ny));
    pet.style.left = `${nx}px`;
    pet.style.top = `${ny}px`;
  };

  // 结束拖动
  const handleEnd = () => {
    isDragging = false;
    setAction('normal', true);
    window.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('mouseup', onMouseUp);
    window.removeEventListener('touchmove', onTouchMove);
    window.removeEventListener('touchend', onTouchEnd);
  };

  const onMouseMove = (e) => handleMove(e.clientX, e.clientY);
  const onMouseUp = () => handleEnd();
  const onTouchMove = (e) => handleMove(e.touches[0].clientX, e.touches[0].clientY);
  const onTouchEnd = () => handleEnd();

  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
  window.addEventListener('touchmove', onTouchMove);
  window.addEventListener('touchend', onTouchEnd);
}

// 点击事件处理
function handleClick() {
  if (isDragging) return;
  
  stopWalk();
  stopIdleTimer();
  setAction('click', true);
  
  setTimeout(() => {
    if (!isDragging) {
      setAction('normal', true);
    }
  }, 2000);
}

// 通用按下处理
function handleDown(startX, startY, onUp) {
  let dragTimer = setTimeout(() => {
    handleDrag(startX, startY);
  }, 100);

  const checkUp = (endX, endY) => {
    clearTimeout(dragTimer);
    const dx = endX - startX;
    const dy = endY - startY;
    if (Math.hypot(dx, dy) < DRAG_THRESHOLD) {
      handleClick();
    }
    onUp();
  };

  return checkUp;
}

// PC端拖动/点击
pet.addEventListener('mousedown', (e) => {
  e.preventDefault();
  const startX = e.clientX;
  const startY = e.clientY;
  
  const checkUp = handleDown(startX, startY, () => {
    window.removeEventListener('mouseup', onMouseUp);
  });

  const onMouseUp = (e) => checkUp(e.clientX, e.clientY);
  window.addEventListener('mouseup', onMouseUp);
});

// 移动端拖动/点击
pet.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  const startX = touch.clientX;
  const startY = touch.clientY;
  
  const checkUp = handleDown(startX, startY, () => {
    window.removeEventListener('touchend', onTouchEnd);
  });

  const onTouchEnd = (e) => {
    const touch = e.changedTouches[0];
    checkUp(touch.clientX, touch.clientY);
  };
  window.addEventListener('touchend', onTouchEnd);
});

// 窗口大小变化时实时校准位置
window.addEventListener('resize', () => {
  const { minX, minY, maxX, maxY } = getBounds();
  let x = getPetX();
  let y = getPetY();
  pet.style.left = `${Math.max(minX, Math.min(maxX, x))}px`;
  pet.style.top = `${Math.max(minY, Math.min(maxY, y))}px`;
  
  if (isWalking) initWalkDirection();
});

// 初始化
startAnim();
setAction('normal');
</script>
</body>
</html>
