<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Danagotchi</title>
<style>
*{
  margin:0;
  padding:0;
  box-sizing:border-box;
  -webkit-user-select:none;
  user-select:none;
  -webkit-touch-callout:none;
}
body{
  overflow:hidden;
  background:#000;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
}
#room{
  position:relative;
  width:100vw;
  height:100vh;
  background-image:url('room.png');
  background-size:cover;
  background-position:center;
  overflow:hidden;
}
#pet{
  position:absolute;
  width:120px;
  height:120px;
  image-rendering:pixelated;
  cursor:grab;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
}
#pet:active{
  cursor:grabbing;
}
</style>
</head>
<body>
<div id="room">
  <img id="pet" src="normal1.png">
</div>

<script>
const pet = document.getElementById('pet');
const room = document.getElementById('room');

const actions = {
  normal: ['normal1.png','normal2.png'],
  click: ['click1.png','click2.png'],
  walk: ['walk1.png','walk2.png'],
  sit: ['sit1.png','sit2.png'],
  lie: ['lie1.png','lie2.png'],
  sleep: ['sleep1.png','sleep2.png'],
  drag: ['drag1.png','drag2.png']
};

let currentAction = 'normal';
let frame = 0;
let frameInterval;

// 动作锁
let isActionPlaying = false;

let isDragging = false;
let startX, startY, petX, petY;

function getBounds(){
  const viewW = document.documentElement.clientWidth;
  const viewH = document.documentElement.clientHeight;
  const petW = 120;
  const petH = 120;
  const maxX = viewW - petW;
  const maxY = viewH - petH;
  return {w: maxX, h: maxY};
}

function rand(min,max){
  return Math.random()*(max-min)+min;
}

// 帧动画
function startAnim(){
  clearInterval(frameInterval);
  frameInterval = setInterval(()=>{
    frame = 1 - frame;
    pet.src = actions[currentAction][frame];
  },500);
}

// 动作锁
function setAction(name, durationMs = 0){
  if(isDragging) return;
  currentAction = name;
  frame = 0;
  pet.src = actions[name][0];

  if(durationMs > 0){
    isActionPlaying = true;
    setTimeout(()=>{
      isActionPlaying = false;
      if(!isDragging) setAction('normal');
    }, durationMs);
  }
}

// 随机待机
const idleActions = ['sit','lie','sleep'];
function randomIdleAction(){
  if(isDragging || isActionPlaying) return;
  const act = idleActions[Math.floor(rand(0,idleActions.length))];
  setAction(act, rand(3000,5000));
}

// 随机走路
function randomWalk(){
  if(isDragging || isActionPlaying) return;

  isActionPlaying = true;
  setAction('walk');

  const {w,h} = getBounds();
  const tx = rand(0, w);
  const ty = rand(0, h);
  const speed = rand(0.05, 0.12);
  const dx = tx - pet.offsetLeft;
  const dy = ty - pet.offsetTop;
  const dist = Math.hypot(dx,dy);
  const duration = dist / speed;

  pet.style.transition = `left ${duration}ms linear, top ${duration}ms linear`;
  pet.style.left = tx + 'px';
  pet.style.top = ty + 'px';

  setTimeout(()=>{
    pet.style.transition = 'none';
    isActionPlaying = false;
    if(!isDragging) setAction('normal');
  }, duration);
}

// AI主循环
function startAI(){
  setInterval(()=>{
    if(!isDragging && !isActionPlaying) randomWalk();
  }, rand(2000,5000));

  setInterval(()=>{
    if(!isDragging && !isActionPlaying) randomIdleAction();
  }, rand(3000,5000));
}

// 点击（优先级最高，不打断拖动）
pet.addEventListener('click',()=>{
  if(isDragging) return;
  setAction('click', 800);
});

// ========== 拖动逻辑 ==========
pet.addEventListener('mousedown',(e)=>{
  isDragging = true;
  isActionPlaying = false;
  setAction('drag');
  pet.style.transition = 'none';
  startX = e.clientX;
  startY = e.clientY;
  petX = pet.offsetLeft;
  petY = pet.offsetTop;
  e.preventDefault();
});
pet.addEventListener('touchstart',(e)=>{
  isDragging = true;
  isActionPlaying = false;
  setAction('drag');
  pet.style.transition = 'none';
  const t = e.touches[0];
  startX = t.clientX;
  startY = t.clientY;
  petX = pet.offsetLeft;
  petY = pet.offsetTop;
  e.preventDefault();
});

window.addEventListener('mousemove',(e)=>{
  if(!isDragging) return;
  const nx = petX + e.clientX - startX;
  const ny = petY + e.clientY - startY;
  pet.style.left = nx + 'px';
  pet.style.top = ny + 'px';
});
window.addEventListener('touchmove',(e)=>{
  if(!isDragging) return;
  const t = e.touches[0];
  const nx = petX + t.clientX - startX;
  const ny = petY + t.clientY - startY;
  pet.style.left = nx + 'px';
  pet.style.top = ny + 'px';
  e.preventDefault();
});

window.addEventListener('mouseup',()=>{
  if(!isDragging) return;
  isDragging = false;
  setAction('normal');
});
window.addEventListener('touchend',()=>{
  if(!isDragging) return;
  isDragging = false;
  setAction('normal');
});

// 启动
startAnim();
setAction('normal');
startAI();
</script></body>
</html>