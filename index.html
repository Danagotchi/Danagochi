<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Danagotchi</title>
<style>
*{
  margin:0;
  padding:0;
  box-sizing:border-box;
  -webkit-user-select:none;
  user-select:none;
  -webkit-tap-highlight-color:transparent;
}
body{
  background:#e8e6d9;
  overflow:hidden;
  height:100vh;
  width:100vw;
}
#pet{
  width:120px;
  height:120px;
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  cursor:grab;
  object-fit:contain;
  /* 让图片不被选中拖拽 */
  -webkit-user-drag:none;
  pointer-events:auto;
}
</style>
</head>

<body>
<img id="pet" src="normal1.png">

<script>
const pet = document.getElementById('pet');

// ==============================================
// 配置
// ==============================================
const PET_SIZE = 120;
const FRAME_INTERVAL = 500; // 1秒2帧
const MOVE_MIN = 2000;
const MOVE_MAX = 5000;
const IDLE_ACTION_MIN = 3000;
const IDLE_ACTION_MAX = 5000;
function getRandomSpeed() {
  return Math.random() * 0.07 + 0.05;
}

// 动作帧
const animations = {
  normal: ['normal1.png', 'normal2.png'],
  click:  ['click1.png', 'click2.png'],
  walk:   ['walk1.png', 'walk2.png'],
  sit:    ['sit1.png', 'sit2.png'],
  lie:    ['lie1.png', 'lie2.png'],
  sleep:  ['sleep1.png', 'sleep2.png'],
  drag:   ['drag1.png', 'drag2.png'],
};

// ==============================================
// 状态
// ==============================================
let currentAnim = 'normal';
let frame = 0;
let frameTimer;
let behaviorTimer;
let isDragging = false;
let isClicking = false;

// 移动
let x = window.innerWidth/2 - PET_SIZE/2;
let y = window.innerHeight/2 - PET_SIZE/2;
let dirX = 0;
let dirY = 0;
let moving = false;

// ==============================================
// 帧动画循环
// ==============================================
function startFrameLoop() {
  clearInterval(frameTimer);
  frameTimer = setInterval(() => {
    const list = animations[currentAnim];
    frame = (frame + 1) % list.length;
    pet.src = list[frame];
  }, FRAME_INTERVAL);
}

function setAnimation(name) {
  if (isDragging) return; // 拖动最高优先级
  if (currentAnim === name) return;
  currentAnim = name;
  frame = 0;
  pet.src = animations[name][0];
}

// ==============================================
// 边界检测
// ==============================================
function clampPos() {
  const maxX = window.innerWidth - PET_SIZE;
  const maxY = window.innerHeight - PET_SIZE;
  x = Math.max(0, Math.min(maxX, x));
  y = Math.max(0, Math.min(maxY, y));
  updatePetPos();
}

function updatePetPos() {
  pet.style.left = x + 'px';
  pet.style.top  = y + 'px';
}

// ==============================================
// 随机移动
// ==============================================
function randomWalk() {
  if (isDragging || isClicking) return;
  moving = true;
  setAnimation('walk');
  const angle = Math.random() * Math.PI * 2;
  const speed = getRandomSpeed();
  dirX = Math.cos(angle) * speed;
  dirY = Math.sin(angle) * speed;
  const moveTime = Math.random()*(MOVE_MAX-MOVE_MIN)+MOVE_MIN;
  setTimeout(() => {
    moving = false;
    dirX = dirY = 0;
    setAnimation('normal');
    setTimeout(idleBehavior, 500);
  }, moveTime);
}

function moveLoop() {
  if (!moving || isDragging || isClicking) return;
  x += dirX;
  y += dirY;
  // 碰壁反弹
  const maxX = window.innerWidth - PET_SIZE;
  const maxY = window.innerHeight - PET_SIZE;
  if (x <= 0 || x >= maxX) dirX *= -1;
  if (y <= 0 || y >= maxY) dirY *= -1;
  clampPos();
  requestAnimationFrame(moveLoop);
}

// ==============================================
// 待机随机动作
// ==============================================
const idleActions = ['sit','lie','sleep'];
function idleBehavior() {
  if (isDragging || isClicking || moving) return;
  const act = idleActions[Math.floor(Math.random()*idleActions.length)];
  setAnimation(act);
  const dur = Math.random()*(IDLE_ACTION_MAX-IDLE_ACTION_MIN)+IDLE_ACTION_MIN;
  setTimeout(() => {
    if (!isDragging && !isClicking && !moving) {
      setAnimation('normal');
    }
  }, dur);
  scheduleNextBehavior();
}

function scheduleNextBehavior() {
  clearTimeout(behaviorTimer);
  const t = Math.random()*(3000)+2000;
  behaviorTimer = setTimeout(() => {
    if (!isDragging && !isClicking && !moving) randomWalk();
  }, t);
}

// ==============================================
// 点击
// ==============================================
function doClick() {
  if (isDragging) return;
  isClicking = true;
  setAnimation('click');
  setTimeout(() => {
    isClicking = false;
    if (!isDragging) setAnimation('normal');
  }, 1000);
}

// ==============================================
// 拖动
// ==============================================
let startX, startY, offX, offY;

function startDrag(e) {
  e.preventDefault();
  isDragging = true;
  setAnimation('drag');
  clearTimeout(behaviorTimer);
  moving = false;
  dirX = dirY = 0;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  offX = clientX - x;
  offY = clientY - y;
}

function moveDrag(e) {
  if (!isDragging) return;
  e.preventDefault();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  x = clientX - offX;
  y = clientY - offY;
  clampPos();
}

function stopDrag() {
  if (!isDragging) return;
  isDragging = false;
  setAnimation('normal');
  scheduleNextBehavior();
}

// 绑定事件
pet.addEventListener('mousedown', startDrag);
window.addEventListener('mousemove', moveDrag);
window.addEventListener('mouseup', stopDrag);
pet.addEventListener('click', doClick);

pet.addEventListener('touchstart', startDrag);
window.addEventListener('touchmove', moveDrag, {passive:false});
window.addEventListener('touchend', stopDrag);

// ==============================================
// 启动
// ==============================================
startFrameLoop();
setAnimation('normal');
scheduleNextBehavior();
moveLoop();

// 窗口大小变化
window.addEventListener('resize', clampPos);
</script>
</body>
</html>
